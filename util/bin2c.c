/*
 * NPLL - Build-time utilities - bin2c
 *
 * Copyright (C) 2025 Techflash
 *
 * Based on code from libstarlet:
 * Copyright (C) 2025 Techflash
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

static const char output_hdr[] =
"/*\n"
" * NPLL - Autogenerated C source - MINI armboot.bin\n"
" * DO NOT MODIFY, AUTOGENERATED SOURCE\n"
" */\n"
"\n"
"#include <npll/types.h>\n";

static const char *input_file = "external/mini/armboot.bin";
static const char *output_c = "src/armboot_bin.c";
static const char *output_h = "src/armboot_bin.h";
static const char *var_name = "__mini_armboot_bin";
static const char *hdr_guard = "_NPLL_ARMBOOT_BIN_H";

int main(void) {
	int ifd, ofdc, ofdh, ret;
	size_t written;
	uint8_t *input;
	char tmp[256];
	struct stat statbuf;
	bool noCloseH = false, noCloseC = false;

	ifd = open(input_file, O_RDONLY);
	if (ifd < 0) {
		perror("open() input");
		goto err_open_in;
	}

	ofdc = open(output_c, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (ofdc < 0) {
		perror("open() output c");
		goto err_open_c;
	}

	ofdh = open(output_h, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (ofdh < 0) {
		perror("open() output h");
		goto err_open_h;
	}

	ret = lseek(ifd, 0, SEEK_SET);
	if (ret) {
		perror("lseek() input");
		goto err_seek_in;
	}

	ret = lseek(ofdc, 0, SEEK_SET);
	if (ret) {
		perror("lseek() output c");
		goto err_seek_c;
	}

	ret = lseek(ofdh, 0, SEEK_SET);
	if (ret) {
		perror("lseek() output h");
		goto err_seek_h;
	}

	ret = write(ofdc, output_hdr, strlen(output_hdr));
	if (ret != strlen(output_hdr)){
		perror("write() output c");
		goto err_write_c;
	}

	ret = write(ofdh, output_hdr, strlen(output_hdr));
	if (ret != strlen(output_hdr)){
		perror("write() output h");
		goto err_write_h;
	}

	ret = stat(input_file, &statbuf);
	if (ret) {
		perror("stat() input");
		goto err_stat_in;
	}

	input = malloc(statbuf.st_size);
	if (!input) {
		perror("malloc() input");
		goto err_malloc_in;
	}

	ret = read(ifd, input, statbuf.st_size);
	if (ret != statbuf.st_size) {
		perror("read() input");
		goto err_read_in;
	}

	sprintf(tmp,
		"#include \"armboot_bin.h\"\n"
		"\n"
		"const int %s_size = %ld;\n"
		"const u8 %s_data[%ld] = {",
		var_name, statbuf.st_size, var_name, statbuf.st_size
	);
	ret = write(ofdc, tmp, strlen(tmp));
	if (ret != (int)strlen(tmp)) {
		perror("write() output c");
		goto err_write_hdrs;
	}

	sprintf(tmp,
		"\n"
		"#ifndef %s\n"
		"#define %s\n"
		"\n"
		"extern const u8 %s_data[%ld];\n"
		"extern const int %s_size;\n"
		"\n"
		"#endif /* %s */\n",
		hdr_guard,
		hdr_guard,
		var_name, statbuf.st_size,
		var_name,
		hdr_guard
	);
	ret = write(ofdh, tmp, strlen(tmp));
	if (ret != (int)strlen(tmp)) {
		perror("write() output h");
		goto err_write_hdrs;
	}

	ret = close(ofdh);
	noCloseH = true;
	if (ret) {
		perror("close() output h");
		goto err_write_hdrs;
	}


	written = 0;
	while (statbuf.st_size--) {

		if ((written % 8) == 0) {
			sprintf(tmp, "\n\t/* 0x%04x */", (int)written);
			ret = write(ofdc, tmp, strlen(tmp));
			if (ret != (int)strlen(tmp)) {
				perror("write() output c");
				goto err_write_real;
			}
		}

		if (statbuf.st_size == 0)
			sprintf(tmp, " 0x%02x\n", input[written]);
		else
			sprintf(tmp, " 0x%02x,", input[written]);

		ret = write(ofdc, tmp, strlen(tmp));
		if (ret != (int)strlen(tmp)) {
			perror("write() output c");
			goto err_write_real;
		}

		written++;
	}

	ret = write(ofdc, "};\n", 3);
	if (ret != 3) {
		perror("write() output c");
		goto err_write_real;
	}

	ret = close(ofdc);
	if (ret) {
		perror("close() output c");
		noCloseC = true;
		goto err_close_c;
	}

	/* don't care if it failed, it was read-only anyways */
	close(ifd);

	return 0;
err_close_c:
err_write_real:
err_write_hdrs:
err_read_in:
	free(input);
err_malloc_in:
err_stat_in:
err_write_h:
err_write_c:
err_seek_h:
err_seek_c:
err_seek_in:
	if (!noCloseH)
		close(ofdh);
err_open_h:
	if (!noCloseC)
		close(ofdc);
err_open_c:
	close(ifd);
err_open_in:
	return 1;
}
